## 알고리즘 문제

- 백준 2차원 배열 연습용 알고리즘 문제
    - 백준 10798번 세로읽기
        - 주소 : https://www.acmicpc.net/problem/10798
        - 로직
            - 세로 5줄은 정해져 있지만, 가로의 경우 최대 15길이에서 랜덤으로 값이 입력됨.
            - 그래서 미리 15 * 5 크기의 빈 배열을 생성하고 위치에 맞게 값을 대입.
            - python에서 for문에 문자열에서 뽑은 문자랑 인덱스를 같이 쓰고 싶으면 enumerate() 함수를 사용하자. 반복문에서 쓰는 요소랑 인덱스를 같이 쓰게 해줌.
            - 이후엔 2중 반복문을 통해 2차원 배열 세로 읽기를 하며 값을 구함.
        - 최종 코드
        
        ```python
        lst = []
        
        line = 5
        max_el = 15
        for i in range(line):
            lst.append([])
            sub_lst = input()
        
            for j in range(max_el):
                lst[i].append("")
        
            for j, sub in enumerate(sub_lst):
                lst[i][j] = sub
        
        text = ""
        
        for width in range(len(lst[0])):
            for height in range(len(lst)):
                text += lst[height][width]
        
        print(text)
        ```
        
    - 백준 2563번 색종이
        - 주소 : https://www.acmicpc.net/problem/2563
        - 로직
            - 주의점! 2차원 이상의 배열을 생성할 때는 리스트 컴프리헨션 필수.
            - `table = [[False] * 100] * 100` << *를 통해서 생성하면 같은 리스트를 참조해서 100개를 만들기 때문. 모든 행이 같은 리스트를 바라보고 있게 되는 것. 그래서 [3][7]의 값을 바꾸면 [0~99][7]의 모든 값이 바뀌게 되는 것임. *는 얕은 참조다! 주의.
            - `table = [[False] * 100 for _ in range(100)]` << 얘는 for문을 통해 전부 새롭게 생성. 서로 독립적인 행 100개가 만들어 지는 것.
        - 최종 코드
        
        ```python
        table = [[False] * 100 for _ in range(100)]
        
        count = int(input())
        true_count = 0
        true_cnt = 0
        
        for i in range(count):
            w, h = map(int, input().split())
        
            for height in range(h, h + 10):
                for width in range(w, w + 10):
                    if table[height][width]:
                        true_cnt += 1
                    table[height][width] = True
                    true_count += 1
                    
        print(true_count - true_cnt)
        
        ```
        
    - 백준 1913번 달팽이
        - 주소 : https://www.acmicpc.net/problem/1913
        - 로직
            - 문제에서 요구하는 것은 아래 방향으로 시작해서 달팽이 모양으로 중앙 방향까지 이동하며 값을 대입하고, 특정 값이 어떤 좌표값에 있는지 출력하는 것.
            - 그래서 이동 방향은 아래 → 오른쪽 → 위 → 왼쪽 이 4가지 방향이 반복된다.
            - 또 다른 규칙으로는 맨 처음엔 3번, 이후엔 2번씩 방향을 바꿀 때마다 해당 방향으로 이동하는 횟수가 1씩 줄어든다.
            - 예를 들면 N이 3이라고 가정하면, 맨 처음 시작할 때는 아래로 2칸, 오른쪽으로 2칸, 위로 2칸을 이동한다.
            - 이후에는 1칸 줄어서 왼쪽으로 1칸. 아래로 1칸. 이렇게 이동하게 된다.
            - 또한, while 문 시작 전에 맨 처음 0, 0 위치의 값을 입력한 후 while 문을 시작하기 때문에 문제에서 요구하는 값의 좌표가 시작 위치에 있는 값 인지 확인해야 한다.
            - 해당 코드에서는 dr, dc 리스트를 이용하여 아래 → 오른쪽 → 위 → 왼쪽 순서로 이동할 수 있도록 구현했다.
        - 최종 코드
        
        ```python
        N = int(input())

        target_number = int(input())

        table = [[0] * (N) for _ in range(N)]

        # 아래 오른쪽 위 왼쪽
        move_count = N - 1 # 특정 방향으로 이동할 횟수
        change_move_count = -1 # 2가 되면 move_count - 1하고 0으로 초기화
        number = N * N # 대입 할 숫자. 이동할 때마다 -1

        row = 0
        col = 0
        dr = [0, 1, 0, -1, 0]
        dc = [0, 0, 1, 0, -1]

        result = []
        if number == target_number:
            result.append(row + 1)
            result.append(col + 1)

        table[row][col] = number
        number -= 1

        while True:

            for i in range(1, 5):

                # 아래로 이동하며 값 채우기
                for _ in range(move_count):
                    row += dr[i]
                    col += dc[i]
                    table[row][col] = number
                    if number == target_number:
                        result.append(row + 1)
                        result.append(col + 1)
                    number -= 1

                change_move_count += 1
                if change_move_count == 2:
                    move_count -= 1
                    change_move_count = 0

            if number == 0:
                break

        for tab in table:
            for val in tab:
                print(val, end=" ")
            print()
            
        print(f"{result[0]} {result[1]}")
        ```