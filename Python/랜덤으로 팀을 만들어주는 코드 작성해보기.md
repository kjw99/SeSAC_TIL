## 랜덤 팀 뽑기 코드

- 총 20명의 인원에서 4명씩 랜덤으로 팀을 이룰 수 있도록 구현.
- 블랙 리스트를 추가해서 특정 인원끼리 팀이 된 경우 다시 팀을 섞는 기능 구현.
- 아래 코드는 팀 리스트를 받아서 랜덤하게 4명끼리 팀을 갖는 팀 리스트를 반환하는 함수.

```python
import random

def random_lunch_team_maker(member_names):
    random.shuffle(member_names)

    teams = []
    team = []

    for name in member_names:
        team.append(name)
        if len(team) == 4:
            teams.append(team)
            team = []
    
    return teams
```

- 아래는 팀 리스트와 블랙리스트를 받아와서 팀 목록에서 블랙리스트에 포함된 조합이 있는지 확인하고, 블랙리스트에 있는 조합이 한 팀에 있다면 False를 반환하는 함수.
- gpt를 통해 개선하기 전의 코드임!
- 해당 코드는 블랙리스트의 조합들 중에서 하나를 가져온 후, 전체 팀 리스트에서 팀 하나씩 확인하면서 블랙리스트의 멤버가 2명 이상이 포함된 팀인지 체크하는 방식.

```python
# 랜덤 팀 목록 중 블랙리스트에 올라온 멤버 조합이 포함되어 있는지 체크
# False는 포함되지 않음. True는 포함됨(다시 랜덤 팀 생성).
def black_list_check(team_list, black_list):

    # 블랙리스트 조합을 하나씩 확인
    for black_team in black_list:

        # 블랙리스트 조합이 1 이하면 한명이거나 없다는 뜻이니까 계산 안하고 다음 루프로.
        if len(black_team) < 2:
            continue

        # 전체 팀 리스트에서 팀 하나씩 확인
        for check_team in team_list:

            # n번 팀에 블랙리스트 조합 멤버가 몇명 포함되었나 체크하는 변수
            check_count = 0
        
            # 블랙리스트 멤버 하나씩 확인.
            for black_member in black_team:
        
                # n번 팀에 블랙리스트 멤버가 포함되었나 확인
                if black_member in check_team:
                    check_count += 1
                    # n번 팀에 블랙리스트 멤버가 같이 있으면 True 반환
                    if check_count > 1:
                        return False
    return True
```

- 아래는 gpt를 통해 개선한 코드.
- **개선점은 set을 사용하고, & 연산을 통해서 가독성과 성능을 챙겼다.**
- **&는 비트 연산, 집합 교집합 연산을 할 때 사용한다. set에서만 사용 가능.**
- 이를 통해 n번 팀과 1~n번 블랙리스트 조합을 각각 교집합해서 일치하는 원소가 2개 이상인 경우 False를 반환하도록 변경.
- 로직 자체는 동일하지만 훨씬 빠르고 간결해졌다.

```python
# 랜덤 팀 목록 중 블랙리스트에 올라온 멤버 조합이 포함되어 있는지 체크
# False는 포함되지 않음. True는 포함됨(다시 랜덤 팀 생성).
def black_list_check(team_list, black_list):

    for check_team in team_list:
        set_check_team = set(check_team)

        for black_team in black_list:
            set_black_team = set(black_team)

            # set을 & 연산. 두 집합에서 공통으로 포함된 것을 뽑고, 그게 2개 이상이면 False
            if len(set_check_team & set_black_team) >= 2:
                return False
    return True
```

- 아래는 전체 코드.

```python
import random

def random_lunch_team_maker(member_names):
    random.shuffle(member_names)

    teams = []
    team = []

    for name in member_names:
        team.append(name)
        if len(team) == 4:
            teams.append(team)
            team = []
    
    return teams

# 랜덤 팀 목록 중 블랙리스트에 올라온 멤버 조합이 포함되어 있는지 체크
# False는 포함되지 않음. True는 포함됨(다시 랜덤 팀 생성).
def black_list_check(team_list, black_list):

    for check_team in team_list:
        set_check_team = set(check_team)

        for black_team in black_list:
            set_black_team = set(black_team)

            # set을 & 연산. 두 집합에서 공통으로 포함된 것을 뽑고, 그게 2개 이상이면 False
            if len(set_check_team & set_black_team) >= 2:
                return False
    return True

names = [
    '강아무개', '김아무개', '곰아무개', '굼아무개', '남아무개', 
    '박아무개', '지아무개', '배아무개', '사아무개', '서아무개', 
    '이아무개', '상아무개', '종아무개', '선아무개', '채아무개', 
    '주아무개', '최아무개', '연아무개', '솔아무개', '연아무개'
    ]

# 같이 밥먹기 싫은 사람을 리스트 형태로 입력
black_list_members = [
    ['강아무개', '김아무개'],
    ['박아무개', '지아무개'],
    ['굼아무개', '상아무개', '선아무개'],
    ['연아무개', '주아무개']
]

loop_count = 0
while True :

    lunch_teams = random_lunch_team_maker(names)
    if black_list_check(lunch_teams, black_list_members):
        break

    loop_count += 1
    if loop_count >= 30:
        print("30번 넘음")
        break

for num in range(len(lunch_teams)):
    print(f"{num + 1}번 팀은 : {lunch_teams[num]} 입니다")
```

- 몇명이 조를 이룰 것인지 입력으로 정하게 하는 기능 추가해보기.
- 총 인원이 18명인데 4명씩 조를 이룰 경우 4 4 4 4 2 가 되는게 아니라 4 4 4 3 3이 되도록 가능한 서로 균등한 인원이 분배될 수 있도록 기능 추가하기
- 강사님 코드를 참고해서 결석자 제외하는 기능을 추가하고 기존 기능을 개선함.
- 결석자 기능
    - 결석자를 입력받고 멤버 리스트에 없는 입력이면 반복 종료. 리스트에 있으면 제외하고 마지막에 출력.
- 랜덤 팀을 만드는 로직을 개선함.
    - 기존 로직은 2차원 배열에서 1번팀부터 채우고 2번팀으로 넘어가는 세로 방향으로 채우는 방식이라면, 새로운 로직은 1번팀 1명, 2번팀 1명, 3번팀 1명 이렇게 가로 형식으로 데이터를 채우는 방식.
    - 이를 위해 팀 개수를 미리 구한 다음 2차원 리스트를 생성하고 팀 개수에 맞게 빈 리스트를 생성함.
    - 이렇게 하면 자연스럽게 각 팀이 균등한 인원으로 분배됨.
- 

```python
import random, math

def get_team_count():
    member_number = int(input("몇명이서 하나의 조를 이룰 것인지 입력해주세요 = "))
    team_count = math.ceil(names_length / member_number)

    return team_count

def exception_member(names):
    
    exception_member_list = []
    while True:
        remove_member = input("결석한 사람을 입력하세요(아무 입력도 없으면 종료) = ")
        if remove_member not in names:
            break
        if remove_member in names:
            names.remove(remove_member)
            exception_member_list.append(remove_member)
    
    print("결석자 :", exception_member_list)
    return names

def random_lunch_team_maker(member_names, team_count):
    random.shuffle(member_names)

    teams = []
    # 팀 카운트에 맞춰서 미리 팀 리스트 추가해놓기.
    for _ in range(team_count):
        teams.append([])

    for i in range(len(member_names)):
        index = i % team_count
        teams[index].append(member_names[i])

    return teams

# 랜덤 팀 목록 중 블랙리스트에 올라온 멤버 조합이 포함되어 있는지 체크
# False는 포함되지 않음. True는 포함됨(다시 랜덤 팀 생성).
def black_list_check(team_list, black_list):

    for check_team in team_list:
        set_check_team = set(check_team)

        for black_team in black_list:
            set_black_team = set(black_team)

            # set을 & 연산. 두 집합에서 공통으로 포함된 것을 뽑고, 그게 2개 이상이면 False
            if len(set_check_team & set_black_team) >= 2:
                return False
    return True

names = [
    '강아무개', '김아무개', '곰아무개', '굼아무개', '남아무개', 
    '박아무개', '지아무개', '배아무개', '사아무개', '서아무개', 
    '이아무개', '상아무개', '종아무개', '선아무개', '채아무개', 
    '주아무개', '최아무개', '연아무개', '솔아무개', '연아무개'
    ]

# 같이 밥먹기 싫은 사람 조합을 리스트 형태로 입력
black_list_members = [
    [],
    [],
    [],
    []
]

loop_count = 0
# 결석자 제외
names = exception_member(names)

names_length = len(names)

# 조 개수 구하기
team_count = get_team_count()

while True :

    # 조 만들기
    lunch_teams = random_lunch_team_maker(names, team_count)
    if black_list_check(lunch_teams, black_list_members):
        break

    loop_count += 1
    if loop_count >= 30:
        print("30번 넘음")
        break

for num in range(len(lunch_teams)):
    print(f"{num + 1}번 팀은 : {lunch_teams[num]} 입니다")
```

- 아래 코드는 남자 / 여자 그룹을 서로 나눠서 고르게 분배될 수 있도록 하나의 그룹이 아닌 2개의 그룹을 사용한 코드.
- 2개의 그룹을 사용하기 때문에 조 개수 구하는 함수나 결석자 구하는 함수, 랜덤 조 생성 함수에서도 살짝 수정을 해줘야 한다.
    - 조 개수에서는 그냥 팀 카운트 계산 과정에서 조 2개를 더한 값과 멤버 수를 나누게 수정
    - 결석자 구하기에서는 1번, 2번 그룹 각각 제외할 사람이 있는지 체크하는 과정 추가 + 반환용 2중 리스트 추가
    - 랜덤 조 생성에서는 1번 그룹을 고르게 분배한 후 2번 그룹을 고르게 분배.
        - 이 과정에서 i 변수의 값은 1, 2그룹 전체 인원 수를 다루도록 하되, 2번 그룹에서 index로 값을 넣어야 하는 과정에서 1번 그룹의 인원수만큼 빼주는 과정을 추가함.
        - 이로 인해 1번 그룹의 끝 부분에서 2번 그룹의 시작 부분을 이어가며 다루도록 함.
            - 각 팀에 고르게 멤버를 분배할 때 1 2 3 4 1 2 3 / 이렇게 끊긴 경우 2번 그룹이 4번 팀부터 멤버를 넣도록 하기 위함.

```python
import random, math

# 조 개수 구하기
def get_team_count():
    member_number = int(input("몇명이서 하나의 조를 이룰 것인지 입력해주세요 = "))
    team_count = math.ceil((names_length_1 + names_length_2) / member_number)

    return team_count

# 결석자 구하기
def exception_member(names, names_1, names_2):
    
    exception_member_list = []
    names_list = [[], []]
    while True:
        remove_member = input("결석한 사람을 입력하세요(아무 입력도 없으면 종료) = ")
        if remove_member not in names:
            break
        if remove_member in names_1:
            names_1.remove(remove_member)
            exception_member_list.append(remove_member)
        if remove_member in names_2:
            names_2.remove(remove_member)
            exception_member_list.append(remove_member)
    
    print("결석자 :", exception_member_list)
    names_list[0] = names_1
    names_list[1] = names_2
    return names_list

# 랜덤 조 생성
def random_lunch_team_maker(names_1, names_2, team_count):
    random.shuffle(names_1)
    random.shuffle(names_2)

    teams = []
    # 팀 카운트에 맞춰서 미리 팀 리스트 추가해놓기.
    for _ in range(team_count):
        teams.append([])

    i = 0
    # 1번 그룹을 각 팀에 고르게 분배
    while i < names_length_1:
        index = i % team_count
        teams[index].append(names_1[i])
        i += 1

    # 2번 그룹을 각 팀에 고르게 분배
    while i < names_length_2 + names_length_1:
        index = (i - names_length_1) % team_count
        teams[index].append(names_2[i - names_length_1])
        i += 1

    return teams

# 랜덤 팀 목록 중 블랙리스트에 올라온 멤버 조합이 포함되어 있는지 체크
# False는 포함되지 않음. True는 포함됨(다시 랜덤 팀 생성).
def black_list_check(team_list, black_list):

    for check_team in team_list:
        set_check_team = set(check_team)

        for black_team in black_list:
            set_black_team = set(black_team)

            # set을 & 연산. 두 집합에서 공통으로 포함된 것을 뽑고, 그게 2개 이상이면 False
            if len(set_check_team & set_black_team) >= 2:
                return False
    return True

names_1 = ['강아무개', '김아무개', '곰아무개', '굼아무개', '남아무개', 
    '박아무개', '지아무개', '배아무개', '사아무개', '서아무개']
names_2 = ['이아무개', '상아무개', '종아무개', '선아무개', '채아무개', 
    '주아무개', '최아무개', '연아무개', '솔아무개', '연아무개']
names = names_1 + names_2

# 같이 밥먹기 싫은 사람 조합을 리스트 형태로 입력
black_list_members = [
    [],
    [],
    [],
    []
]

loop_count = 0
# 결석자 제외
names_list = exception_member(names, names_1, names_2)

names_1 = names_list[0]
names_2 = names_list[1]

names_length_1 = len(names_1)
names_length_2 = len(names_2)

# 조 개수 구하기
team_count = get_team_count()

while True :

    # 조 만들기
    lunch_teams = random_lunch_team_maker(names_1, names_2, team_count)
    if black_list_check(lunch_teams, black_list_members):
        break

    loop_count += 1
    if loop_count >= 30:
        print("30번 넘음")
        break

for num in range(len(lunch_teams)):
    print(f"{num + 1}번 팀은 : {lunch_teams[num]} 입니다")
```
## 강사님 코딩 과정

- n명의 인원으로 조를 짜고 싶다.
- 총 인원을 입력받는다.
- 총 인원을 n으로 나누고 올림 처리한다. 해당 값이 그룹 카운트가 됨.
    - 이러면 21명을 4인 1조로 나눈다면 6개 팀이 생김.
- 이후 각 그룹에 인원을 채워넣되, 하나의 그룹에 4명씩 한번에 채우는게 아니라 한 팀에 한명씩 채워넣어서 가능한 균등하게 인원 분배가 되도록 구현.
    - 이를 위해 2중 배열을 사용. teams = [ [] for _ in range(group_count) ]
- 인원을 섞기 전에 결석자를 따로 입력 받아서 제외하는 로직을 구현.
- 결석자 제외, 조 개수 찾기, 조 만들기 등 기능을 가능한 함수로 따로 구현함.
- 남 여 2개의 그룹으로 나눠야 한다면??
    - 각 그룹에 결석자를 제거하는 로직 추가.
    - 그룹 카운트를 구할 때도 전체 인원 부분이 남자 그룹 + 여자 그룹 이런식으로 바뀌게 됨
    - 각 팀에 1명씩 인원을 넣는 로직에서 남자 그룹을 골고루 넣은 후 여자 그룹을 골고루 넣게 바꿔야 한다.
        - 이 과정에서 index를 관리할 방법이 필요함. 그룹 별로 사용하는 인덱스와 전체 인덱스 2가지의 인덱스를 관리해야 한다.